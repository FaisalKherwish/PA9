// HEADER FILE
#include "ObjectManager.hpp"

class Game
{
public:
	Game();

	void runGame();
	void respawnFruit(std::vector<std::unique_ptr<ObjectManager>>& fruitObjects);

private:
	int mLives;
	int mCombo;
	int mRoundTime;
};


// CPP FILE
#pragma once

#include "Game.hpp"
#include "Objects.hpp"
#include "Utility.hpp"

#include <iostream>
#include <SFML/Window.hpp>
#include <SFML/Graphics.hpp>


Game::Game()
{
	this->mLives = 3;
	this->mCombo = 0;
	this->mRoundTime = 0;

	
}

void Game::runGame()
{
	sf::RenderWindow gameWindow(sf::VideoMode({ 1080,1080 }), "Fruit Slicers");
	
	

	sf::Font timerFont("C:\\Users\\ThemN\\OneDrive\\Desktop\\Project\\Sources\\Japers-DK3W.ttf");
	sf::Text roundTimer(timerFont);
	roundTimer.setFillColor(sf::Color::White);
	roundTimer.setCharacterSize(32);
	roundTimer.setPosition(sf::Vector2f(900, 900));
	roundTimer.setString(std::to_string(this->mRoundTime));

	std::vector<std::unique_ptr<ObjectManager>> fruitObjects;
	fruitObjects.push_back(std::make_unique<Watermelon>());
	fruitObjects.push_back(std::make_unique<Watermelon>());


	sf::RectangleShape rect;
	rect.setSize(sf::Vector2f(100, 100));
	rect.setFillColor(sf::Color::Red);
	rect.setPosition(sf::Vector2f(400, 400));

	while (gameWindow.isOpen())
	{

		while (const std::optional event = gameWindow.pollEvent())
		{
			if (event->is<sf::Event::Closed>()) gameWindow.close();

			if (sf::Mouse::isButtonPressed(sf::Mouse::Button::Left))
			{

				sf::Vector2i mouseWindowPosition = sf::Mouse::getPosition(gameWindow);
				sf::Vector2f mouseWorldPosition = gameWindow.mapPixelToCoords(sf::Vector2i(mouseWindowPosition.x, mouseWindowPosition.y));

				for (const auto& fruit : fruitObjects)
				{
					if (fruit->getShape().getGlobalBounds().contains(mouseWorldPosition))
					{
						std::cout << "Sliced: " << fruit->getName() << std::endl;
					}
				}

				sf::FloatRect rectbox = rect.getGlobalBounds();
				if (rectbox.contains(mouseWorldPosition)) std::cout << "rect test";
			}
		}

		// Update game states
		this->mRoundTime++;
		roundTimer.setString(std::to_string(mRoundTime));

		// fruit position update
		for (int i = 0; i < fruitObjects.size(); ++i)
		{
			auto& fruit = fruitObjects[i];
			fruit->gravity();

			
			if (fruit->getShape().getPosition().y > 1080)
			{
				fruitObjects.erase(fruitObjects.begin() + i);
				respawnFruit(fruitObjects); 
				--i; 
			}
		}

		// render
		gameWindow.clear();

		// drawing
		gameWindow.draw(roundTimer);
		gameWindow.draw(rect);
		for (const auto& fruit : fruitObjects)
		{
			fruit->draw(gameWindow);
		}

		gameWindow.display();

	}

	

}

void Game::respawnFruit(std::vector<std::unique_ptr<ObjectManager>>& fruitObjects)
{
	fruitObjects.push_back(std::make_unique<Watermelon>());
}
